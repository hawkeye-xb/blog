---
title: js事件循环
date: 2024-06-10T07:47:40.000Z
draft: true
---

在浏览器中，事件循环主要关注两个队列：宏任务队列（macrotask queue）和微任务队列（microtask queue）。在每次事件循环迭代中，浏览器会从宏任务队列中取出一个任务执行，然后检查微任务队列，执行其中的所有任务，直到微任务队列为空。这个过程确保了微任务能够及时得到处理，而不会被宏任务阻塞。

在 Node.js 中，事件循环被划分为多个阶段，每个阶段处理特定类型的宏任务。这些阶段包括 timers、pending callbacks、poll、check 和 close callbacks。在每个阶段结束时，Node.js 会检查微任务队列（包括 process.nextTick 和 Promise 的回调），并执行其中的所有任务，直到微任务队列为空。然后，事件循环会进入下一个阶段。

下面是 Node.js 事件循环的一个简化流程：

进入 timers 阶段，执行所有定时器的回调。

在进入下一个阶段之前，检查微任务队列，执行所有 process.nextTick 和 Promise 的回调，直到微任务队列为空。

进入 pending callbacks 阶段，执行系统操作的回调。

在进入下一个阶段之前，再次检查微任务队列，执行所有 process.nextTick 和 Promise 的回调，直到微任务队列为空。

重复这个过程，直到事件循环的所有阶段都被处理完毕。

因此，您的描述是正确的：在 Node.js 中，如果在一个 timer 的回调中添加了微任务，这些微任务会在 timers 阶段结束时执行，而不是在下一个 timer 的回调执行之前。这与浏览器的行为不同，浏览器会在每个宏任务执行完毕后立即检查并执行微任务队列中的任务。

总结来说，浏览器和 Node.js 的事件循环在处理微任务时有所不同。浏览器在每次宏任务执行后立即检查微任务队列，而 Node.js 在每个事件循环阶段结束时检查微任务队列。这种差异反映了两种环境中异步操作的不同处理方式。